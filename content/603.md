Title: Drupal 7 - tworzenie pierwszego modułu
Date: 2012-07-08 21:51
Author: filipgorczynski
Category: Programowanie
Tags: .info, .module, Drupal, drupal 7, moduł, moduły
Slug: 603
Status: draft

Every .info file must declare which files in the module contain PHP  
functions, classes, or interfaces  
JavaScript, CSS, image files, and PHP files (like templates) that do not contain functions that the module needs to know about needn't be included in files\[\] directives. The point of the directive is simply to indicate to Drupal that these files should be examined by Drupal  
plays a very important role is the dependencies\[\] directive. This is used to list the other modules that must be installed and active for this module to function correctly. Drupal will not allow  
a module to be enabled unless its dependencies have been satisfied.  
The initial doc block in the code fragment above begins with the \@file decorator. This indicates that the doc block describes the file as a whole, not a part of it. Every file should begin with a file-level doc block.  
Drupal defines a hook called hook\_help(). The help hook is invoked (called) when  
a user browses the help system. Each module can have one implementation of  
hook\_help()  
How does this function become a hook implementation? Strictly by virtue of its name: first\_help(). The name follows the hook pattern. If the hook is named hook\_help(), then to implement it, we replace the word hook with the name of  
the module. Thus, to implement hook\_help(), we simply declare a function in  
our first module named first\_help().  
Each hook has its own parameters, and all core Drupal hooks are documented at http://api.drupal.org.

hook\_help()  
hook\_block\_info()  
hook\_block\_view()

hook\_block\_info() The purpose of this hook is to tell Drupal about all of the blocks that the module provides.

Note that, as with any hook, you only need to implement it in cases where your module needs to provide this functionality. In other words, if the hook is not implemented, Drupal will simply assume that this module has no associated blocks

An implementation of hook\_block\_info() takes no arguments and is expected  
to return an associative array.

The returned array should contain one entry for every block that this module declares, and the entry should be of the form \$name =\> array(\$property =\> \$value).

\$blocks\['list\_modules'\] = array(  
'info' =\> t('A listing of all of the enabled modules.'),  
'cache' =\> DRUPAL\_NO\_CACHE,  
);  
This defines a block named list\_modules that has two properties  
http://api.drupal.org/api/function/hook\_block\_info/7

An implementation of hook\_block\_view() is expected to take one argument—the name of the block to retrieve—and return an array of data for the given name

The argument that our first\_block\_view() function takes, is the name of the block

theme('item\_list', array());  
module\_list();

To format an array of strings into an HTML list, we use the item\_list theme, and we pass in an associative array containing two variables:  
- the items we want listed  
- the type of listing we want  
From theme() we get a string of HTML.

An implementation of hook\_block\_view() is expected to return an array with two items in it:  
- subject: The name or title of the block.  
- content: The content of the block, as formatted text or HTML.

As with other files in a module, the file containing the unit tests needs to be declared in the module's .info file  
This simply tells Drupal to inspect the contents of this file during execution.  
When the testing framework is invoked, it will find the tests automatically by inspecting the  
contents of first.test.  
Once your module is installed, Drupal caches the contents of the .info file. After adding a new item to the file, you should re-visit the Modules page to force Drupal to re-parse the .info file

Most test cases follow a simple pattern:  
Create a new class that extends DrupalWebTestCase  
Add a getInfo() function  
Do any necessary configuration in the setUp() method  
Write one or more test methods, beginning each method with the word test  
In each test method, use one or more assertions to test actual values

Naming conventions and Classes  
Drupal functions are named in all lowercase, with words separated by underscore (\_) Classes and methods are different. Classes should be named in uppercase "CamelCase" notation, with the first letter capitalized. Methods should be named in "camelCase" with the first letter in lowercase. Underscores should not be used in class or method names.

The getInfo() method returns an array with three items:  
- name: The name of the test.  
- description: A sentence describing what the tests do.  
- group: The name of the group to which these tests belong.

The getInfo() function might seem, at first blush, to be unimportant, but your test, absolutely must have it. Otherwise, the test case will not be made available for execution.

Again, a setup method is not strictly necessary, but when you use one it must have  
at least the lines shown in the example above.

module\_invoke('first', 'block\_info');

function called module\_invoke(), storing its results in \$info. The module\_invoke() function calls a particular hook for a particular module  
This function is the infrequently used counterpart of module\_invoke\_all(), which executes a hook in all of the modules in which that hook appears.

Drupal calls the process of wrapping your data in HTML and CSS as theming

http://api.drupal.org/api/drupal/includes!module.inc/function/module\_invoke/7  
http://api.drupal.org/api/drupal/includes!module.inc/function/module\_invoke\_all/7

Since a module is most intimately familiar with its own data and functionality,  
it's the module's responsibility to provide the default theme implementation  
As long as the module uses the theme system properly, a theme will be able to override any HTML and CSS by hot-swapping its own implementation for the module's implementation.

Sometimes a particular theme will need to override your implementation in order for it to achieve a specific design goal; if the theme provides its own implementation, Drupal will use the theme implementation instead of the module's default implementation.  
By calling the theme() function, we are delegating the responsibility of determining and using the proper theme implementation.  
In addition to API hooks, Drupal also has theme hooks. A theme hook is simply the name of a particular way to markup some data. For example, passing data to the item\_list theme hook will result in different markup then passing data to the links theme hook. However, while normally every module's hook function will be called when Drupal invokes an API hook, only one theme hook implementation will be invoked when Drupal invokes a theme hook.  
While normally every module's hook function will be called when Drupal invokes an API hook, only one theme hook implementation will be invoked when Drupal invokes a theme hook.

There are actually two different ways you can make an implementation, but for now we'll only talk about the simplest method for module developers—theme functions

When you call theme(), it will look for a default theme function named theme\_HOOKNAME and for an optional theme override function called THEMENAME\_HOOKNAME. If you dig into Drupal's internals, you'll find a theme\_item\_list() inside includes.inc or theme.inc. This is Drupal's default theme implementation for an item\_list. If our active theme was Bartik, and if Bartik implemented a theme override called bartik\_item\_list(), then theme() would use the Bartik theme's implementation instead of the default one.

The preceding figure shows one piece of data as it passes through a module and a theme. However, in order for you to understand the full power of Drupal's theme layer, you also need to understand how the entire page is built.

Since modules don't need to know anything about the structure of the theme and its ancestry, we'll simply talk about "the theme" in this book. Just be aware that the actual theme may be more complex.
